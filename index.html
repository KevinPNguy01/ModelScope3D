<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<link rel="icon" type="image/svg+xml" href="/stanford_bunny.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>3D Model Viewer</title>
		<script
		src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"
		integrity="sha512-zhHQR0/H5SEBL3Wn6yYSaTTZej12z0hVZKOv3TwCUXT1z5qeqGcXJLLrbERYRScEDDpYIJhPC1fk31gqR783iQ=="
		crossorigin="anonymous"
		defer>
		</script>
	</head>
	<body>
		<script id="lines-vertex-shader" type="x-shader/x-vertex">
			uniform mat4 uModelViewProjectionMatrix;

			attribute vec3 aPosition;
			attribute vec3 aColor;

			varying vec3 vColor;

			void main() {
				gl_Position = uModelViewProjectionMatrix * vec4(aPosition, 1.0);
				vColor = aColor;
			}
		</script>
		<script id="lines-fragment-shader" type="x-shader/x-fragment">
			precision mediump float;

			varying vec3 vColor;

			void main() {
				gl_FragColor = vec4(vColor, 0.75);
			}
		</script>
		<script id="triangles-vertex-shader" type="x-shader/x-vertex">
			uniform mat4 uModelMatrix;
			uniform mat4 uViewMatrix;
			uniform mat4 uProjectionMatrix;
			uniform mat4 uNormalMatrix;      

			attribute vec3 aVertexPosition;     // Vertex position in object space
			attribute vec3 aVertexNormal;       // Vertex normal in object space
			attribute vec2 aTextureCoord;

			varying vec3 vFragPos;             	// Vertex position in world space
			varying vec3 vNormal;               // Vertex normal in world space
			varying vec2 vTextureCoord;

			void main(void) {
				vFragPos = vec3(uModelMatrix * vec4(aVertexPosition, 1.0));
				vNormal = vec3(uNormalMatrix * vec4(aVertexNormal, 1.0));
				vTextureCoord = aTextureCoord;

				gl_Position = uProjectionMatrix * uViewMatrix * vec4(vFragPos, 1.0);
			}
		</script>
		<script id="triangles-fragment-shader" type="x-shader/x-fragment">
			precision mediump float;

			struct Material {
				vec3 ambient;
				vec3 diffuse;
				vec3 specular;
				float shininess;
			}; 

			struct DirLight {
				vec3 direction;
				vec3 color;
			};

			struct PointLight {    
				vec3 position;
				
				float constant;
				float linear;
				float quadratic;  

				vec3 color;
			};  

			uniform PointLight pointLight;
			uniform Material material;
			uniform DirLight dirLight;

			uniform sampler2D uSampler;
			uniform vec3 uCamPos;

			varying vec3 vFragPos;
			varying vec3 vNormal;
			varying highp vec2 vTextureCoord;

			vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir) {
				vec3 lightDir = normalize(-light.direction);
				vec3 halfwayDir = normalize(lightDir + viewDir);
				// diffuse shading
				float diff = max(dot(normal, lightDir), 0.0);
				// specular shading
				vec3 reflectDir = reflect(-lightDir, normal);
    			float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
				// combine results
				vec3 ambient  = light.color * material.ambient;
				vec3 diffuse  = light.color * diff * texture2D(uSampler, vTextureCoord).rgb;
				vec3 specular = light.color * spec * material.specular;
				return (ambient + diffuse + specular);
			}

			vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir) {
				vec3 lightDir = normalize(light.position - fragPos);
				vec3 halfwayDir = normalize(lightDir + viewDir);
				// diffuse shading
				float diff = max(dot(normal, lightDir), 0.0);
				// specular shading
				float spec = pow(max(dot(normal, halfwayDir), 0.0), material.shininess);
				// attenuation
				float distance = length(light.position - fragPos);
				float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));    
				// combine results
				vec3 ambient  = light.color * material.ambient;
				vec3 diffuse  = light.color * diff * texture2D(uSampler, vTextureCoord).rgb;
				vec3 specular = light.color * spec * material.specular;
				ambient  *= attenuation;
				diffuse  *= attenuation;
				specular *= attenuation;
				return (ambient + diffuse + specular);
			} 

			void main() {
				vec3 norm = normalize(vNormal);
				vec3 viewDir = normalize(uCamPos-vFragPos);

				if (dot(norm, viewDir) < 0.0) {
					norm = -norm;
				}

				vec3 result = CalcDirLight(dirLight, norm, viewDir);
				result += CalcPointLight(pointLight, norm, vFragPos, viewDir);    
				
				gl_FragColor = vec4(result, 1.0);
			}
		</script>
		<div id="root"></div>
		<script type="module" src="/src/app/main.tsx"></script>
	</body>
</html>
